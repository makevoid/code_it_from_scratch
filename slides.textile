
h1. Code it from scratch

RubyDay 2013

@makevoid


> notes: create wifi, connect ipad and test buttons/notes
> deactivate moz fb plugin, put in fullscreen, open display preferences, close every other software, open quicktime and start recording (file > new screen recording)

---


who am I?

@makevoid

Ruby developer

Recently discovered 3D printing!

> Lately I'm becoming interested in 3d printing (code that become real things), but I'm a newbie, so If you know a lot about that, come and talk to me


---

IDEA &#128161;


> you have an idea for an app

> you want to start to code it

> how many times the first thing you have done is this?

---


```bash
$ rails new appname
```

> and maybe it was only for a static site, for a json API, or for a clientside app?

> maybe you have seen the rails build blog in 15 minutes screencast a lot of times

> have you thought, maybe it's not the best or the fastest to start an app, or start playing with some code

> or... have you ever seen this?

[bg black]
[colour green]

---

```bash
$ rake test
```

[terminal]
---

```bash
$ rake test
..
```

[terminal]
---

```bash
$ rake test
.....
```

[terminal]
---

```bash
$ rake test
.........
```

[terminal]
---

```bash
$ rake test
...............
```


> or maybe you started a fresh app:
[terminal]
---

(freshly created app)

```bash
$ rails console
```

...after 2 secs

```bash
irb(main):001:0>
```

---

... after adding 10+ gems ...

---

```bash
$ rails console
```

---

```bash
$ rails console
```

(...)

> rails console yuuuhuu

---

```bash
$ rails console
```

... after 15 secs ...

```bash
irb(main):001:0>
```

---

```bash
$ rails console
```

... after 15 secs ...

```bash
irb(main):001:0>
```

WTF!!!

---

...

> have you ever saw something like that? if yes

> for the next app think about...

---

h1. Coding it from scratch!

---

] problems:

- when you are starting, the less you have the better!
- library you require and their dependencies are code that you don't control directly
  - it can be complex
  - can have bugs
  - can slow your app down 
  
---


Did you...

- wait for minutes for a test suite to finish
- discovered a feature you need in library "x" is not implemented
- hit bugs in the library x and realized it's gazillion lines of long messy code?
- spent more time in searching documentation than 

so for the next project consider coding it from scratch!

[note: there will be some slides full of code, and links, so if you are interested you may follow along with bit.ly/codeifs ]  

---

solution:

go back to ruby

> start both from only basic ruby 

> or/and from the frontend, yes, i'm talking about a plain html file

> at first do only the things you need the most, your app's core

> only after consider integrating other's people code and libraries 

---

START small in:

---

START small in: EVERYTHING

---

- Ruby

---

- Ruby
- HTML/CSS

---

- Ruby
- HTML/CSS
- JS

> this is only a 30min talk, I can't show you all the things but some examples of very small small starting points and going on after that


---

Ruby:

&#x1F4DD;

> in ruby:

> let's say you want to build a Blog, you will need a post model


---


Don't &#9995;

```bash
$ rails new myapp
```

---

/ prefer something more like 

h2. sinatra

---

&#9995;

> don't do this:

and even in sinatra:

```ruby
class Post < ActiveRecord::Base

end
```

> the moment you do that your code is not small anymore!


---

- start from sinatra 
- transition into rails if you need

(you can always mount a rack app (like sinatra) in the rails router - SOA )

> service oriented architecture

---

```ruby
class Post
  # uuh... plain ruby
end
```


---

```ruby
class Post
  # can't you hear the sound of freedom?
end
```

---

...

> ok, what I'm going to show you it's really basic, but bare with me


---



```ruby
class Post
  attr_accessor :title
  attr_accessor :content
  
  def initialize(attrs={})
    @title    = attrs[:title]
    @content  = attrs[:content]
  end
end
```

---

```ruby
post = Post.new( title: "ruby", 
  content: "when it's plain, it's powerful" )
post.title #=> "ruby"
```

> this may seem too basic, but believe me, it's convenient!

> and you can easily go beyond that!

> NEXT: for a model library:

---

datas == array of hashes

---

```bash
people = [person1, person2]
```

---

```bash
people = [{ #person1
          }, 
          { #person2
          }] 
```

--- 

in ruby:

```ruby
[
  { name: "mario", age: 28 }, 
  { name: "luigi", age: 32 },
  # ...   
]
```

--- 

or in json (.to_json is your friend):

```javascript
[
  { "name": "mario", "age": 28 }, 
  { "name": "luigi", "age": 32 }
  // ...
]
```

---

you can use eval (it's evil only in production, in development can be time saving)

```ruby
def load_posts(user_id)
  { # ... }
end

[
  { id: 1, name: "mario", age: 28, 
    posts: load_posts(1) 
  }
].sort_by{ #... }
```

when developing, write your data in a file, so you don't need to query a database, you can just open that file


---

load them into objects

```ruby
@posts = posts.map do |post|
  Post.new( title: post.title, 
  content: post.content )
end
```
  
  
--- 

when developing

do you really need persistence?


> when developing, do you really need persistence? most of the time not! you need datas that persist in memory

---

what is "in memory" in ruby??

---

what is memory in ruby??

(a "variable"!)

---

what is memory in ruby??

a @@class_variable!

---

what is memory in ruby??

a @@class_variable!

a CONSTANT!

---

what you need:

---

what you need:

good seed datas

> most of the times
> you need just good seed datas


---

scale later

> you can always scale later to a more production-ready solution, but your development time and process is the key

---

data is code, code is data


---


data > write to file

```ruby
objects = [{}, {}]

File.open("./db/data.rb", "w") do |f|
  f.write objects
end
```

> your collection of objects can be easily wrote to file

---

read file > eval contents > data!


```ruby
objects = File.read "./db/data.rb"

puts objects #=> [{}, {}]
```

> ..and you can simply retrieve them with an eval (of course you can use yaml/json/redis/pstore if you prefer)

---


you can dynamically load datas and modify your objects with few lines

attr_accessor and instance_variable_set are your friends!

---

]]]]]] SKIP TO CODE RELOADING

]]]]]] CONTINUE WITH RUBY EXAMPLES


---

```ruby
key = :antani
instance_variable_set "@#{key}", val

# at class level
attr_accessor key
```

---


```ruby
# how to get to class level?

def self.included(mod)
  mod.send :extend, ClassMethods
end

module ClassMethods
  def create_accessor(name)
    attr_accessor name
  end
end
```


without method missing
without instance/class eval

those are not very clear to debug, isn't it?


---

```ruby
class Page
  def self.create_accessors(hash)
    attr_accessor *hash.keys
  end

  def self.load(hash)
    page = Page.new
    page.load hash
    page.classify_contents
    page
  end

  def load(hash)
    Page.create_accessors hash
    load_contents hash
  end

  private

  def load_contents(hash)
    hash.map do |key, val|
      instance_variable_set "@#{key}", val
    end
  end
end
```

---

available as a gem: "github/makevoid/blizz":https://github.com/makevoid/blizz

but as the code it's simple, I suggest coding it yourself personalizing it :) 

---


then of course you can use it


```ruby
hash = { title: "test", contents: "bla" }
page = Page.load hash

page.title #=> "test"
page.contents #=> "bla"
```    
    
> test
    
with nested embedded objects:

```ruby
post_hash = { 
  title: "test", 
  comments: ["bla", "asd", "lol"] 
}
```
    
(simple)

---

more complex:

```ruby
post_hash = { 
  title: "test", 
  comments: [
    { id: 1, text: "bla", user_id: 1 },
    { id: 2, text: "asd", user_id: 2 },
    { id: 3, text: "lol", user_id: 1 },
    #...
  ]
}
```


go crazy and find your own way!

---

then you want to use activerecord? easy, your external api looks already like that!

  
---
  
or use ActiveModel?
or YAML::Store (stdlib),
PStore (stdlib),
Virtus (datamapper2/ROM)

---


h1. ruby

use net http from scratch
[example]

```ruby
example = Net::HTTP.get_response "http://example.com"
puts example #=> "example!"
```

> always run it and see the output!

---

```ruby
def get_example
  Net::HTTP.get_response "http://example.com"
end

get_example()
```

---


in a class:


```ruby
class Antani
  # long list of methods

  def get_example
    Net::HTTP.get_response "http://example.com"
  end

  def parse_example
    example = get_example
    example.gsub(/example/, 'EXAMPLE') 
  end
end
```


---

or:

```ruby
class Antani
  # long list of methods

  def get_example
    @example = Net::HTTP.get_response "http://example.com"
  end

  def parse_example
     @example.gsub(/example/, 'EXAMPLE') 
  end
end
```

---

```ruby
class Antani

  include Example


module Example

  def get_example
    # ...

  def parse example
    # ....
```

(pseudo code)

---

when you don't have rails

you don't have autoload / autoreload

---

simple autoload -> require + Dir.glob

```ruby
def require_all(dir)
  Dir.glob("#{dir}/*.rb").each do |file|
    require file
  end
end

require_all "models"
```

---

autoreload

ctrl+C + up arrow + enter &#x1F600;

rerun [link]

guard-reload [link]

> if your [dev env/setup] is slow, you are developing at turtle speed &#x1F422;

> your integration tests will be automatically slow because they will require your environment

hotkeys (osx / linux)
- fastscripts
- gnome-???? forgot the name


---

use pseudo-code

use pseudo-code

use pseudo-code

use pseudo-code

use pseudo-code


write pseudo code, then implement it in real language

---

email_my_ip.rb

```ruby
# gets my ip and emails it to me
```

---

email_my_ip.rb

```ruby
# get my ip from icanhazip.com
# emails it to me@example.com
```

---


email_my_ip.rb


```ruby
def email_ip
  # get my ip from icanhazip.com
  # emails it to me@example.com
end

email_ip
```

> create main method and call it

---

```ruby
def email_ip
  ip = get_ip
  mail_me_ip ip
end

def get_ip
end

def mail_me_ip(ip)
end

email_ip
```

> create actual methods


---

```ruby
require 'net/http'

def get_ip
  
end
```

> implement them 

---


- models / DDD


> ruby part:

> models: stated before


> diobubu?

---

there are a lot of functions in stdlib, use them!

---


cuuuustooooom foooormaaats!!!

(saf, textile/markdown + extensions [github flavored markdown, it's just a pre/post parser] , pre-parsed sass for themed variables ..., write code that writes code :) )

textile/markdown are meant to be used in static, easily editable, files, many blogging engines like jekyll or static sites generator use markdown/textile

if you are building a cms or you let user input some 

[youtube_ID] -> <object>youtube embed</object>
[vimeo_ID] -> <object>youtube embed</object>

[audio_ID] -> <audio></audio>
[image_ID] -> <img src="./path/to/imgs/ID.png" />

[....] -> 

simple regexes

/\[youtube_(.+)\]/

/\[image_(\d+)\]/



---


IMPORTANT

think about having an env file

require './env'

to do `irb -r ./env.rb` and have your environment loaded (like script/console)

---

look at different requiring mechanisms

require "file" # standard, you don't have to change it from gem
require "./file" 
require_relative "file"

append to $LOAD_PATH # i don't like a lot this approach

# my favourite

path = File.expand_path "../", __FILE__
require "#{path}/file"


# main class

class App
  @@path = File.expand_path "../", __FILE__
end


# where there's "../" you will put your root project dir level

---

example: 

app dir /
  |
  -- app.rb
  -- ..

# in app.rb it will be "../"

---

app dir /
  |
  -- lib/
      |
      -- app.rb
      -- ..
  -- ..

# in app.rb it will be "../../", etc...


---

h1. CSS / SASS


# SASS

css resets


don't use compass or html5 boilerplate (reset what you care about)


compass > bourbon > custom mixins

> if you use *compass* drop to *bourbon* then drop to custom mixins 

finalize when you have to ship it, don't overoptimize prematurely!

---

my favourite css reset:

```css
// right, just that

body {
  margin: 0;
}
```

---

// and if you use links

```css
a {
  text-decoration: none
}
```

---

```css
// support IE

img {
  border: 0
}
```

---

SASS hands on:

do layouts by yourself

don't use css frameworks / grid systems / boilerplates

use box-sizing for layouts

```css
box-sizing: border-box
```

it allows you to think about the content width without too many calculations
you can mix fluid (%/em) widths and fixed paddings (in px) 

[your playground it's always ready]

---

```html
// index.html

<style>
  div {
    box-sizing: border-box
  }
</style>

<div>this is a valid html page</div>
```


---

box-sizing example:


```html
<style>
  body, html {
    margin: 0;
  }

  div {
    box-sizing: border-box;
    float: left;
    width: 50%;
    padding: 20px;
    background: lightGrey; // to show them
  }
</style>

<div>a div</div>
<div>another div</div>
```

---

without horizontal padding

<div class="layout_example1">a div</div>
<div class="layout_example1">another div</div>

---

with a bit of padding

<div class="layout_example2">a div</div>
<div class="layout_example2">another div</div>

---

more padding, width remains 50%

<div class="layout_example3">a div</div>
<div class="layout_example3">another div</div>

---

note: needs to be prefixed in FF

```javascript
-moz-box-sizing: border-box;
```

works only in IE8+


---

hack CSS, create your own SASS mixins:


```css
=box_sizing
  -moz-box-sizing: border-box
  box-sizing: border-box

=box
 +box_sizing
 float: left

you can go really crazy with that

=left
  float: left
  
=right
  float: right
  
=center
  margin: 0 auto
    
=center_text
  text-align: center
  
# legacy browser support center
  
=center
  margin: 0 auto
  text-align: center
  *
    text-align: center

=hidden
  display: none

=bg($bg) // why bg? because background is too long/hard to type ^^
  background: $bg

=rounded($amount)
  +border_radius($amount)
  
=vmargin($top, $bot: $top)
  margin-top: $top
  margin-bottom: $bot
  
// hmargin, vpadding, hpadding
```

---



use SASS/Less/etc variables and operations:

for layout:

```sass
# SASS example

$main: 80%
$side: 2%
$rest: $main - $side*2
```

---

create more complex layout system using variables:


use color operations to create themes!

```css
body
  color: #C00       // red
  background: #EEE  // light grey 
```

---

extract the colors you use into variables

```css
$main_color: #C00
$bg_color: #EEE

body
  color: $main_color
  background: $bg_color
```

---



```css
$main_color: #C00
$bg_color: #EEE

body
  background: $bg_color
```

---

```css
a
  color: $main_color
a:hover
  color: $main_color + #222 // makes the links brigher on hover
  
.content
  background: $bg_color - #222 // makes the bg darker
```

---


```css
$main_color: #00A
$bg_color: #EFE
```

> and if you change the variables, you change the colors! here's your theme generator

---

there are many more color functions like

```css
darken()
lighten()
adjust_hue()
colorize()
grayscale()
alpha()
...
```

"more":http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html



---

Ruby developers
focus a lot on backends and
focus less on frontend [we forget that html/css/js (for ux elements) is also programming, especially when css preprocessors are involved]

---

Do it yourself, you'll save time in the end:

Sinatra over Rails
SASS over Compass
JS over JQuery Plugins

If you code something, from the ground up, you are sure that you do it based on what you need.

But! It will take more time, sure :D


---

h1. JS

build your own:
  - click events
  - image gallery
  - autocomplete
  - infinite page scrolling
  - manage history state (push/pop)State yourself
  - please don't use pjax / fast-rails-hack-ajax-speed-reload-antani?
  - 
  
also don't use ; they are optional! (except when you use the wrapping namespace () ) - (function(){ }) 

use zepto instead of jquery - if you don't plan to support ie 8

---

click event example:

```javascript
// with jquery/zepto

$("a.clickable").on("click", function(evt){
  console.log("clicked")
  evt.preventDefault()
})
```

---

```javascript
// that becomes:

var link = $("a.clickable")
link.on("click", function(evt){
  console.log("clicked")
  evt.preventDefault()
})
```

---

```javascript
// and finally:

var link = $("a.clickable")
var handle_click = function(evt){
  console.log("clicked")
  evt.preventDefault()
}
link.on("click", handle_click)
```

---

```javascript
// plain js

var link = document.querySelector("a.clickable")
var handle_click = function(evt){
  console.log("clicked")
  evt.preventDefault()
}
link.addEventListener("onclick", handle_click)
```

not that hard isn't it?

---


querySelector

```javascript
img = document.querySelector("img.antani")

Q = document.querySelector
( QA = document.querySelectorAll )
$ = document.querySelector
```

---

```javascript
img = $("img.antani")
img = Q("img.antani") 
```

tip: use specific tags in your js (especially if a specific tag like an img/audio/video/section/span/caption...)


otherwise you always have to do get(0) to get to the real element


---


data attributes

```javascript
// jquery
img.data("id")
```

---

```javascript
// wouldn't be better if it was
img.data.id  // ?
```

---

```javascript
// well in js is really like this
img.dataSet.id
```

oh but if you use jquery you need  ("") 


----

also for classes (addClass/reomveClass)
and for appending/prepending to the dom
innerHTML += / insertBefore / appendElement


> // prototyping // dealing with change // "lean" // "agile" // insert buzzword here! // from a fucking blank editor!  you know?  
img.dataset.id


other examples: 
http://www.leebrimelow.com/native-methods-jquery/


---

underscore js

underscore.js is very cool because it adds to js a lot of useful functions that make it more like ruby!

Array [Enumberables] (each, map, count, sum ...)
String (...)
Function (throttle, once...)



BUT: dont use it like shown in the examples :D

---

```javascript
_([array]).map ... -> ...
```

not

```javascript
_.map([array], ->)
```

:)

because so you can refactor as

```javascript
var array = _([array])
```

---

and you can do

```javascript
array.map(....
```

---

and you can do

```javascript
array.map(....
```

it feels more like ruby

---

IMPORTANT: MAKE YOUR CODE EASY TO READ (in the frontend world) means also  MAKE YOUR HTML/CSS Easy to read

---

> skip this part!!! the important list is after this!

> awesome for open source


> remember when you started with building web sites/apps (and what you do mostly do to evaluate them?)

you open the site/app and click around, play with it
and next,  yes -> View source

---

[and that is exactly what makes me mad about not being able to do it on desktop/mobile(ios/android) apps]

that's why i love web technologies (html5/js etc) and even if we have a big elder brother that is very slow (yeah i'm talking about W3C)

--- 

I like standards, especially if they're easy, to give the possibility to anyone to create things, and maybe become more of a programmer or designer

we have the ability to make, it's inside our human nature, we can make things that can change the world!!!

---

note:

if you use compilers (especially html and css) make sure they output a good code
or make your sources public (repository/put them in the same public directory and "link" to them with a comment <!-- --> // ) 


---

- router/controllers
 - sinatra over rails
 - router over controller 
  - mount rack apps directly on router
 - catchall controller
 - api controller / no need for full ActionController (yeah, more metal &#127928; &#9835; , more speed)

---

- APIs
 
--- 
 
- view
  - pagination
  - form helpers (basic version is easy, validation integration can be tricky, especially with i18n)
  - link helpers
  - meta tags
  - js/css includes
  - HAML/Slim

---
  
- workflow automation (guard)
  - compiling ( sass/less -> css,  coffee -> js )
  - browser reloading
  - concatenating
  - minifying
  (sprockets is slow isn't it? use guard [show guard-concat code])
  
---


use guard
to automate your workflow / coding sessions

[all guards available list] (github search)

guard-coffeescript
guard-sass
guard-livereload
guard-concat
  
---  
  
- testing
  - test model in isolation, require only what you need (multiple spec helpers)
  - sinatra over rails (blazing fast integration testing)
  - custom/in memory/redis/datamapper/sequel over activerecord

---


for sites / clientside apps

start with an empty index.html

open it in your browser

when you need to host it use something like

python SimpleHTTP server

then maybe move to sinatra 

then maybe move to rails (the total code weight will increase drastically in this phase &#x1F600; )

--- 

then tear down some defaults (you usually don't need all actioncontroller 

also see one file rails app and one file rails app and the talk by jose - railsnatra http://www.confreaks.com/videos/2442-railsconf2013-you-ve-got-a-sinatra-on-your-rails )

---

when choosing a library

some things are important:

size (number of lines) 
code quality
test coverage
require time (something that most people ignore, this impacts both development and testing time)

---

I've gone / I'm pushing it  to the extreme just to see when it's useful and when it's not

see where is your limit

try to go beyond that and to see if you benefit from it


to see wich library/technology to try and how to try it

search the library author name
find a talk about his library

---

CIY (Code it Yourself)

like DIY for things, if it's cheaper
in the end you will learn something new
or if you already know those things (let's say you need a pagination library) you can do it for exercise
to try a new TDD/BDD/etc way of coding
to train yourself

[warning: I'm not saying that you should rebuild EVERYTHING, that could be "a little" time consuming :)]
so don't rebuild rails if you need every part of it

instead, if you code something, and you see it's [simpler / solves the problem better / it has a feature that other libs don't / has a better api]
release that code as a library

- reuse it in other projects
- let other people use it, open source it
-- if people ask for features
-- tell people to fork it and implement those themselves


---

i'm not saying it's easy, especially with a big and "already running in production" project, but! you surely have another 

so, before you add x^n dependencies, consider to code it from a blank environment



---

important:

coding from scratch keep your programmer memory fresh
less cut n paste
you need to produce
more modular code
more targeted code

less: use this or that library, hammer 2-3 things here and there and go
you are more forced to think about the problem and about the language / apis you have
before using an external library think: do I really need it?
doing this will I save time in the end?

---


write method names you are going to implement BEFORE implementing them

---


don't block impelementing a method and then using it
---
start from outside the onion
---
>> it's seems fucking stupid but think about it

---

a complete area of your brain makes analysis, your prefrontal cortex, then you have a creative part, located on the back sides of your head  

there is a cost in switching between analytic and creative (intuition) mode, you should should maximize the two phases, I think

so, again, code it from the fucking scratch

---


reach the MVP (minimal viable product)
MVD (minimal viable demo)
then iterate on that

> say that to those LEAN guys

---

prefer small iterations over big upfront overstructured designs

follow the "flow"


---

code

:: notes: these are presenter notes
:: layout it's just a class

[layout mini] 
[font thaoma]
[color red]
---

Thanks!

questions?

---

Thanks!

questions?


rubies 3d printed @ LTE Studio 


